#include <iostream>
#include <vector>
#include <numeric>
#include <cmath>
#include <map>
#include <string>
#include <stdexcept>
#include <algorithm>
#include "json.hpp" // Make sure to include this header

using json = nlohmann::json;

// A simple struct to hold a share's coordinates
struct Share {
    long long x;
    long long y;
};

// Function to convert a string value from a given base to base 10
long long convertToBase10(const std::string& value, int base) {
    long long result = 0;
    long long power_of_base = 1;
    for (int i = value.length() - 1; i >= 0; i--) {
        char c = value[i];
        int digit;
        if (c >= '0' && c <= '9') {
            digit = c - '0';
        } else if (c >= 'a' && c <= 'z') {
            digit = 10 + (c - 'a');
        } else {
            throw std::invalid_argument("Invalid character in value string.");
        }
        if (digit >= base) {
            throw std::invalid_argument("Invalid digit for the given base.");
        }
        result += digit * power_of_base;
        power_of_base *= base;
    }
    return result;
}

// Function for modular exponentiation (a^b mod m)
long long power(long long base, long long exp, long long mod) {
    long long res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp % 2 == 1) res = (res * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return res;
}

// Function to find the modular inverse using Fermat's Little Theorem
long long modInverse(long long n, long long mod) {
    return power(n, mod - 2, mod);
}

// Function to perform Lagrange interpolation
long long lagrange_interpolate(long long x, const std::vector<Share>& points, long long prime) {
    long long result = 0;
    int n = points.size();

    for (int i = 0; i < n; ++i) {
        long long xi = points[i].x;
        long long yi = points[i].y;
        long long numerator = 1;
        long long denominator = 1;

        for (int j = 0; j < n; ++j) {
            if (i == j) continue;
            long long xj = points[j].x;
            numerator = (numerator * (x - xj + prime)) % prime;
            denominator = (denominator * (xi - xj + prime)) % prime;
        }

        long long term = (yi * numerator) % prime;
        long long inv_denom = modInverse(denominator, prime);
        term = (term * inv_denom) % prime;
        result = (result + term + prime) % prime;
    }
    return result;
}

// Reconstructs the secret from a set of shares
long long reconstruct_secret(const std::vector<Share>& shares, int k, long long prime) {
    if (shares.size() < k) {
        throw std::runtime_error("Not enough shares to reconstruct the secret.");
    }
    std::vector<Share> points_to_use;
    for (int i = 0; i < k; ++i) {
        points_to_use.push_back(shares[i]);
    }
    return lagrange_interpolate(0, points_to_use, prime);
}

// Main logic to process the JSON input and find the secret/corrupt shares
int main() {
    json data;
    try {
        std::cin >> data;
    } catch (const std::exception& e) {
        std::cerr << "Error reading JSON from stdin: " << e.what() << std::endl;
        return 1;
    }

    int k = data["keys"]["k"];
    long long prime = -1;
    
    // Check if the input contains a prime, which indicates a modular arithmetic problem.
    // Otherwise, assume it's a large number, non-modular problem.
    if (data.contains("prime")) {
        prime = data["prime"].get<long long>();
    } else {
        prime = 999999999999999989; 
    }

    std::vector<Share> shares;
    // Check for the new JSON structure with top-level keys
    if (data.contains("1") && data["1"].contains("base")) {
        for (auto const& [key, val] : data.items()) {
            if (key == "keys") continue;
            long long x = std::stoll(key);
            int base = std::stoi(val["base"].get<std::string>());
            std::string value_str = val["value"].get<std::string>();
            try {
                long long y = convertToBase10(value_str, base);
                shares.push_back({x, y});
            } catch (const std::exception& e) {
                std::cerr << "Error converting share: " << e.what() << std::endl;
                return 1;
            }
        }
    } else if (data.contains("shares")) {
        // This is for the previous standard JSON structure.
        for (const auto& item : data["shares"]) {
            long long x = item["x"].get<long long>();
            int base = item["base"].get<int>();
            std::string value_str = item["value"].get<std::string>();
            try {
                long long y = convertToBase10(value_str, base);
                shares.push_back({x, y});
            } catch (const std::exception& e) {
                std::cerr << "Error converting share: " << e.what() << std::endl;
                return 1;
            }
        }
    } else {
        std::cerr << "Error: Invalid JSON format. Unable to determine test case type." << std::endl;
        return 1;
    }

    if (k > shares.size()) {
        std::cerr << "Error: Not enough shares to satisfy the threshold k." << std::endl;
        return 1;
    }

    std::map<long long, int> secret_counts;
    std::vector<int> indices(shares.size());
    std::iota(indices.begin(), indices.end(), 0);
    
    std::vector<bool> combo_selector(shares.size());
    std::fill(combo_selector.begin() + shares.size() - k, combo_selector.end(), true);
    
    do {
        std::vector<Share> current_combo;
        for (int i = 0; i < shares.size(); ++i) {
            if (combo_selector[i]) {
                current_combo.push_back(shares[i]);
            }
        }
        try {
            long long secret = reconstruct_secret(current_combo, k, prime);
            secret_counts[secret]++;
        } catch (const std::runtime_error& e) {}
    } while (std::next_permutation(combo_selector.begin(), combo_selector.end()));

    if (secret_counts.empty()) {
        std::cout << "Could not reconstruct the secret." << std::endl;
        return 1;
    }
    
    long long true_secret = -1;
    int max_count = 0;
    for (const auto& pair : secret_counts) {
        if (pair.second > max_count) {
            max_count = pair.second;
            true_secret = pair.first;
        }
    }
    
    std::sort(shares.begin(), shares.end(), [](const Share& a, const Share& b) {
        return a.x < b.x;
    });

    std::vector<Share> valid_shares_subset;
    for (size_t i = 0; i < shares.size(); ++i) {
        valid_shares_subset.push_back(shares[i]);
        if (valid_shares_subset.size() == k) break;
    }

    std::vector<Share> corrupt_shares;
    for(const auto& share : shares) {
        long long expected_y = lagrange_interpolate(share.x, valid_shares_subset, prime);
        if (expected_y != share.y) {
            corrupt_shares.push_back(share);
        }
    }

    if (corrupt_shares.empty()) {
        std::cout << "The reconstructed secret is: " << true_secret << std::endl;
    } else {
        std::cout << "the secret is:" << true_secret << std::endl;
        std::cout << "the wrong secret is:" << corrupt_shares[0].y << std::endl;
        std::cout << "participant " << corrupt_shares[0].x << " is corrupt" << std::endl;
    }
    
    return 0;
}
